/**
 * VERUM OMNIS PDF LAYOUT UTILITY
 * 
 * This module implements the mandatory PDF layout ruleset for all PDF outputs
 * generated by the Verum Omnis repository. It ensures:
 * - Text fits cleanly within each page without overflow
 * - Automatic adjustment of content to avoid clipping
 * - Reserved bottom-right corner for QR Code on every page
 * - Safe print margins for court and forensic admissibility
 */

import { jsPDF } from 'jspdf';

/**
 * A4 Page Dimensions in millimeters
 */
export const PAGE_DIMENSIONS = {
  WIDTH: 210,   // A4 width in mm
  HEIGHT: 297,  // A4 height in mm
} as const;

/**
 * Standard margins for forensic documents (in millimeters)
 */
export const MARGINS = {
  TOP: 25,      // Top margin
  LEFT: 20,     // Left margin
  RIGHT: 20,    // Right margin
  BOTTOM: 30,   // Bottom margin (extra space for QR zone)
} as const;

/**
 * Reserved QR Code Zone (bottom-right corner) in millimeters
 */
export const QR_CODE_ZONE = {
  WIDTH: 45,    // QR code width
  HEIGHT: 45,   // QR code height
  PADDING: 5,   // Padding around QR code
} as const;

/**
 * Calculate the position of the QR code in the bottom-right corner
 */
export const getQRCodePosition = () => ({
  x: PAGE_DIMENSIONS.WIDTH - MARGINS.RIGHT - QR_CODE_ZONE.WIDTH,
  y: PAGE_DIMENSIONS.HEIGHT - MARGINS.BOTTOM - QR_CODE_ZONE.HEIGHT,
  width: QR_CODE_ZONE.WIDTH,
  height: QR_CODE_ZONE.HEIGHT,
});

/**
 * Calculate the safe text area, excluding margins and QR code zone
 */
export const getSafeTextArea = () => {
  const qrPos = getQRCodePosition();
  
  return {
    // Left boundary
    x: MARGINS.LEFT,
    // Top boundary
    y: MARGINS.TOP,
    // Available width (full width minus left and right margins)
    width: PAGE_DIMENSIONS.WIDTH - MARGINS.LEFT - MARGINS.RIGHT,
    // Available height (page height minus top margin and bottom margin)
    // Content should stay above the QR code zone
    maxHeight: qrPos.y - MARGINS.TOP - QR_CODE_ZONE.PADDING,
    // Right boundary where QR code starts (with padding)
    maxX: PAGE_DIMENSIONS.WIDTH - MARGINS.RIGHT,
    // Bottom boundary where QR code starts (with padding)
    maxY: qrPos.y - QR_CODE_ZONE.PADDING,
  };
};

/**
 * Check if there's enough space remaining on the current page for content
 * @param currentY - Current Y position on the page
 * @param requiredHeight - Height required for the next content block
 * @returns true if content fits, false if page break needed
 */
export const hasSpaceForContent = (currentY: number, requiredHeight: number): boolean => {
  const safeArea = getSafeTextArea();
  return (currentY + requiredHeight) <= safeArea.maxY;
};

/**
 * Calculate the remaining height available on the current page
 * @param currentY - Current Y position on the page
 * @returns Remaining height in mm
 */
export const getRemainingPageHeight = (currentY: number): number => {
  const safeArea = getSafeTextArea();
  return Math.max(0, safeArea.maxY - currentY);
};

/**
 * Word-aware text splitting that respects line breaks and word boundaries
 * @param pdf - jsPDF instance
 * @param text - Text to split
 * @param maxWidth - Maximum width for each line
 * @returns Array of text lines
 */
export const splitTextToLines = (pdf: jsPDF, text: string, maxWidth: number): string[] => {
  const paragraphs = text.split('\n');
  const lines: string[] = [];
  
  for (const paragraph of paragraphs) {
    if (paragraph.trim() === '') {
      lines.push('');
      continue;
    }
    
    const splitLines = pdf.splitTextToSize(paragraph, maxWidth);
    lines.push(...splitLines);
  }
  
  return lines;
};

/**
 * Measure the height of a text block
 * @param pdf - jsPDF instance
 * @param text - Text to measure
 * @param maxWidth - Maximum width for text
 * @param lineHeight - Line height multiplier (default: 1.15)
 * @returns Height in mm
 */
export const measureTextHeight = (
  pdf: jsPDF,
  text: string,
  maxWidth: number,
  lineHeight: number = 1.15
): number => {
  const lines = splitTextToLines(pdf, text, maxWidth);
  const fontSize = pdf.getFontSize();
  // Convert font size from points to mm (1 point = 0.352778 mm)
  const fontSizeMm = fontSize * 0.352778;
  return lines.length * fontSizeMm * lineHeight;
};

/**
 * Add text with automatic page breaks
 * @param pdf - jsPDF instance
 * @param text - Text to add
 * @param x - X position
 * @param y - Current Y position
 * @param options - Optional configuration
 * @returns New Y position after adding text
 */
export const addTextWithPageBreak = (
  pdf: jsPDF,
  text: string,
  x: number,
  y: number,
  options: {
    maxWidth?: number;
    lineHeight?: number;
    align?: 'left' | 'center' | 'right' | 'justify';
    onNewPage?: (pageNumber: number) => void;
  } = {}
): number => {
  const safeArea = getSafeTextArea();
  const maxWidth = options.maxWidth || safeArea.width;
  const lineHeight = options.lineHeight || 1.15;
  const align = options.align || 'left';
  
  const lines = splitTextToLines(pdf, text, maxWidth);
  const fontSize = pdf.getFontSize();
  const fontSizeMm = fontSize * 0.352778;
  const lineHeightMm = fontSizeMm * lineHeight;
  
  let currentY = y;
  let pageNumber = pdf.getCurrentPageInfo().pageNumber;
  
  for (const line of lines) {
    // Check if we need a new page
    if (!hasSpaceForContent(currentY, lineHeightMm)) {
      pdf.addPage();
      pageNumber++;
      currentY = safeArea.y;
      
      if (options.onNewPage) {
        options.onNewPage(pageNumber);
      }
    }
    
    // Add the line
    if (align === 'center') {
      pdf.text(line, PAGE_DIMENSIONS.WIDTH / 2, currentY, { align: 'center' });
    } else if (align === 'right') {
      pdf.text(line, safeArea.maxX, currentY, { align: 'right' });
    } else {
      pdf.text(line, x, currentY);
    }
    
    currentY += lineHeightMm;
  }
  
  return currentY;
};

/**
 * Add a QR code to the reserved zone on the current page
 * @param pdf - jsPDF instance
 * @param qrCodeDataUrl - Data URL of the QR code image
 */
export const addQRCodeToReservedZone = (pdf: jsPDF, qrCodeDataUrl: string): void => {
  const qrPos = getQRCodePosition();
  pdf.addImage(qrCodeDataUrl, 'PNG', qrPos.x, qrPos.y, qrPos.width, qrPos.height);
};

/**
 * Add footer content ensuring it stays above the QR code zone
 * @param pdf - jsPDF instance
 * @param leftText - Text for left side of footer
 * @param centerText - Text for center of footer
 * @param rightText - Text for right side of footer (will be placed left of QR code)
 */
export const addFooterAboveQRZone = (
  pdf: jsPDF,
  leftText?: string,
  centerText?: string,
  rightText?: string
): void => {
  const qrPos = getQRCodePosition();
  const safeArea = getSafeTextArea();
  
  // Footer text should be positioned above the QR zone
  const footerY = qrPos.y - 5; // 5mm above QR code
  
  pdf.setFontSize(8);
  pdf.setTextColor('#94a3b8'); // slate-400 color
  
  if (leftText) {
    pdf.text(leftText, MARGINS.LEFT, footerY);
  }
  
  if (centerText) {
    pdf.text(centerText, PAGE_DIMENSIONS.WIDTH / 2, footerY, { align: 'center' });
  }
  
  if (rightText) {
    // Place right text to the left of the QR code zone
    const maxRightX = qrPos.x - 5; // 5mm left of QR code
    pdf.text(rightText, maxRightX, footerY, { align: 'right' });
  }
};

/**
 * Initialize a new jsPDF instance with standard Verum Omnis settings
 */
export const createVerumOmnisPDF = (): jsPDF => {
  return new jsPDF({
    orientation: 'portrait',
    unit: 'mm',
    format: 'a4',
  });
};

/**
 * Helper class to manage PDF layout state
 */
export class PDFLayoutManager {
  private pdf: jsPDF;
  private currentY: number;
  private pageNumber: number;
  private qrCodeDataUrl?: string;
  
  constructor(pdf?: jsPDF) {
    this.pdf = pdf || createVerumOmnisPDF();
    this.currentY = getSafeTextArea().y;
    this.pageNumber = 1;
  }
  
  getPDF(): jsPDF {
    return this.pdf;
  }
  
  getCurrentY(): number {
    return this.currentY;
  }
  
  setCurrentY(y: number): void {
    this.currentY = y;
  }
  
  getPageNumber(): number {
    return this.pageNumber;
  }
  
  setQRCode(qrCodeDataUrl: string): void {
    this.qrCodeDataUrl = qrCodeDataUrl;
  }
  
  /**
   * Add a new page and reset position
   */
  addPage(): void {
    this.pdf.addPage();
    this.pageNumber++;
    this.currentY = getSafeTextArea().y;
  }
  
  /**
   * Check if content fits on current page, add new page if needed
   */
  ensureSpace(requiredHeight: number): void {
    if (!hasSpaceForContent(this.currentY, requiredHeight)) {
      this.addPage();
    }
  }
  
  /**
   * Add text with automatic page breaks
   */
  addText(
    text: string,
    options: {
      x?: number;
      fontSize?: number;
      maxWidth?: number;
      lineHeight?: number;
      align?: 'left' | 'center' | 'right' | 'justify';
    } = {}
  ): void {
    const safeArea = getSafeTextArea();
    const x = options.x || safeArea.x;
    
    if (options.fontSize) {
      this.pdf.setFontSize(options.fontSize);
    }
    
    this.currentY = addTextWithPageBreak(this.pdf, text, x, this.currentY, {
      maxWidth: options.maxWidth || safeArea.width,
      lineHeight: options.lineHeight,
      align: options.align,
      onNewPage: () => {
        this.pageNumber++;
      },
    });
  }
  
  /**
   * Add spacing
   */
  addSpacing(height: number): void {
    this.currentY += height;
    this.ensureSpace(0); // Check if we've gone past the safe zone
  }
  
  /**
   * Add QR code to all pages
   */
  addQRCodeToAllPages(qrCodeDataUrl: string): void {
    const totalPages = this.pdf.getNumberOfPages();
    
    for (let i = 1; i <= totalPages; i++) {
      this.pdf.setPage(i);
      addQRCodeToReservedZone(this.pdf, qrCodeDataUrl);
    }
  }
  
  /**
   * Finalize PDF by adding QR codes to all pages
   */
  finalize(): void {
    if (this.qrCodeDataUrl) {
      this.addQRCodeToAllPages(this.qrCodeDataUrl);
    }
  }
}
